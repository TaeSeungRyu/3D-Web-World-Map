
var camera, scene, renderer, controls, stats;
//requestAnimationFrame 동작 확인
var rAF = null, cRAF = null;
var base_globe = new Object();
const radius = 0.988;
const hover_scale = 1.055;
const segments = 64;
const continents = ["EU", "AN", "AS", "OC", "SA", "AF", "NA"];
const EARTH_SIZE = 20;

var overlay_element = null;
var main_element = null;
var isSelected = {result:false,name:null};

function start_app() {
    main_element = document.getElementById('map-canvas');
    overlay_element = document.getElementById('overlay');
    init();
    animate();
}

function init() {
    if (!Detector.webgl) {
        Detector.addGetWebGLMessage();
    }

    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor('#1C2833',0.8);

    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(main_element.clientWidth, main_element.clientHeight);

    //레더링 버거울경우 반으로 줄이자 > 하지만 너무 작아서 안보일수도...
    // renderer.setSize(main_element.clientWidth/2, main_element.clientHeight/2);

    main_element.appendChild(renderer.domElement);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, main_element.clientWidth / main_element.clientHeight, 0.01, 4500);

    //카메라 시작 위치를 대한민국으로 세팅
    camera.position.x = -224;
    camera.position.y = 187;
    camera.position.z = 170;

    // scene.add(new THREE.AmbientLight(0x555555));
    scene.add(new THREE.AmbientLight(0xffffff));

    const lights = [[-1,1,1],[-1,1,-1],[1,1,-1],[1,1,1]];
    lights.forEach(function(itm){  //조명 위치
        const light = new THREE.DirectionalLight(0xaaaaaa, 0.5);
        // const light = new THREE.PointLight(0xaaaaaa, 0.5);
        light.position.set(itm[0], itm[1], itm[2]).normalize();
        scene.add(light);
    });

    base_globe = new THREE.Object3D();
    base_globe.scale.set(EARTH_SIZE, EARTH_SIZE, EARTH_SIZE);
    scene.add(base_globe);
    scene.updateMatrixWorld(true);

    sea_texture = THREE.ImageUtils.loadTexture('textures/sea.jpg', THREE.UVMapping, function () {
        sea_texture.wrapS = THREE.RepeatWrapping;
        sea_texture.wrapT = THREE.RepeatWrapping;
        sea_texture.repeat.set(16, 8);
        base_globe.add(new THREE.Mesh(
        new THREE.SphereGeometry(radius, segments, segments),
        new THREE.MeshLambertMaterial({
            transparent: true,
            depthTest: true,
            depthWrite: false,
            opacity: 0.85,
            map: sea_texture,
            // color: '#0082FA'
            color: '#00D8FF'
        })));

        for (var name in country_data) {
            var geometry = new Tessalator3D(country_data[name], 0);
            var color = new THREE.Color(0xff0000);
            //지구본 국가별 색상 입히기
            color.setHSL(continents.indexOf(country_data[name].data.cont) * (1 / 7), Math.random() * 0.25 + 0.45, Math.random() / 2 + 0.25);
            var mesh = country_data[name].mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
                color: color
            }));
            mesh.name = "land";
            mesh.updateMatrixWorld(true);
            mesh.userData.country = name;
            base_globe.add(mesh);
            base_globe.updateMatrixWorld(true);

            var sum_x = 0;
            var sum_y = 0;
            var sum_z = 0;
            geometry.vertices.forEach( function (datas){
                sum_x += datas.x;
                sum_y += datas.y;
                sum_z += datas.z;
            });
            if(name == 'United States'){
                sum_x = 0.705254386270839 * geometry.vertices.length;
                sum_y = 0.6588207712606129 * geometry.vertices.length;
                sum_z = 0.2618614939262992 * geometry.vertices.length;

            }
            var addNum = 1.03;
            if(name == 'Australia' || name == 'China' || name == 'Russian Federation' || name == 'United States' || name == 'Canada' || name == 'Brazil'){
                addNum = 1.12;
            }

            sum_x = sum_x / geometry.vertices.length  * addNum;
            sum_y = sum_y / geometry.vertices.length  * addNum;
            sum_z = sum_z / geometry.vertices.length  * addNum;

            //위도, 경도 표시한 막대기길이 현재 랜덤으로 데이터 처리 중
            var value = Math.random() * 300 + 15;
            // var value = 315;

            var cubeMat = new THREE.MeshLambertMaterial({side: 2, opacity:0.6});

            //BoxGeometry - width, height, depth, widthSegments, heightSegments, depthSegments
            var geoForLine = new THREE.BoxGeometry( 0.5,0.5,1+value/8,1,1,1 );

            //나라별 위도, 경도 막대기바 SET
            var cube = new THREE.Mesh( geoForLine, cubeMat );

            cube.castShadow  = true;
            cube.position.set(sum_x, sum_y, sum_z);

            //x축과 y축이 같은값이면 정사각형 막대기로 생성
            cube.scale.x = 0.02; //막대기 넓이 x축 길이
            cube.scale.y = 0.02; //막대기 넓이 y축 길이
            cube.scale.z = 0.003; // 막대기 높이;
            cube.lookAt( new THREE.Vector3(0,0,0) );

            // 막대기 색상 처리 16진수입력
            cube.material.color.setHex(0xff0000);

            // 투명도 설정
            cube.material.transparent = true;
            cube.material.opacity = 0.8;

            // 막대기 연결점의 모양
            // cube.material.wireframe = true;
            // cube.material.wireframeLinejoin = "round";
            // cube.material.wireframeLine = 5;
            mesh.add(cube);

            //******************************임시******************************
            // 지구본에 글씨 집어넣기 -
            insertTextOnGlobe(name, sum_x*20, sum_y*20, sum_z*20, color);
            //******************************임시******************************

            //******************************임시******************************
            //나라에서 나라 flight line처리
            /*
            var onePoint = 0.75;
            var twoPoint = 1.05;

            var middle_x = 0;
            var middle_y = 0;
            var middle_z = 0;
            var mul = 19.9;

            //한국기준 처리
            var kor_x = -0.6511796956614361 * mul;
            var kor_y = 0.6057371400042327 * mul;
            var kor_z = 0.4979957922184134 * mul;

            sum_x *= mul;
            sum_y *= mul;
            sum_z *= mul;
            if(name == "South Korea"){
              console.log(name)
              console.log("sum X >"+sum_x+"   Y >"+sum_y+"    Z >"+sum_z);
            }
            if(name != "South Korea"){
              middle_x = (kor_x + sum_x) * onePoint;
              middle_y = (kor_y + sum_y) * onePoint;
              middle_z = (kor_z + sum_z) * onePoint;
              var middle_x2 = middle_x * twoPoint;
              var middle_y2 = middle_y * twoPoint;
              var middle_z2 = middle_z * twoPoint;

              if(name == "China" || name == "Brazil"){
                console.log(name)
                console.log("sum X >"+sum_x+"   Y >"+sum_y+"    Z >"+sum_z);
                console.log("mid X >"+middle_x+"   Y >"+middle_x+"    Z >"+middle_x);
              }


              var curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3 ( kor_x, kor_y, kor_z ),
                new THREE.Vector3( middle_x, middle_y, middle_z ),
                new THREE.Vector3( middle_x2, middle_y2, middle_z2 ),
                new THREE.Vector3( sum_x, sum_y, sum_z )
              );
              var curveGeometry = new THREE.Geometry();
              curveGeometry.vertices = curve.getPoints( 50 );
              var curveMaterial = new THREE.LineBasicMaterial({
                color : 0xFFA500, linewidth: 1, linecap: 'round', linejoin:  'round'
              });
              var curveLine = new THREE.Line( curveGeometry, curveMaterial );
              scene.add(curveLine);
            }else{
              continue;
            }
            */
            //******************************임시******************************
        }
    });

    controls = new THREE.TrackballControls(camera, renderer.domElement);
    // controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.rotateSpeed = 1;
    controls.zoomSpeed = 1.0;
    controls.noZoom = false;
    controls.noPan = false;
    controls.staticMoving = false;
    controls.minDistance = 23.0;
    controls.maxDistance = 70.0;
    controls.dynamicDampingFactor = 0.1;

    //******************************임시******************************
    //하늘곡선 임시 하드코딩 테스트용
    var testFlightArr = ["China", "Brazil", "Germany", "Uganda"];
    for(t in testFlightArr){
      fligthLineTestFunc(testFlightArr[t]); //
    }
    // fligthLineTestFunc(testFlightArr[0]);
    //******************************임시******************************

    //******************************임시******************************
    // 지구본에 글씨 집어넣기 -
    // insertTextOnGlobe("대한민국", -13.02, 12.11, 9.95);
    //******************************임시******************************

    //이벤트 처리
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('click', onGlobeClick, false);
}

//일반 이름 클릭 이벤트 처리, 강제로 넣는기능이므로 국가별 보정작업이 차후 완료되어야 한다.
function moveByClickedName(evt,search_name) {
    if(evt != undefined && evt != null){
      evt.preventDefault();
      evt.stopPropagation();
    }

    var search_data = country_data[search_name];
    if(search_data == undefined || search_data == null){
        return;
    }

    var geometry = new Tessalator3D(search_data, 0);
    var sum_x = 0;
    var sum_y = 0;
    var sum_z = 0;

    geometry.vertices.forEach( function (datas){
        sum_x += datas.x;
        sum_y += datas.y;
        sum_z += datas.z;
    });

    sum_x = sum_x / geometry.vertices.length;
    sum_y = sum_y / geometry.vertices.length;
    sum_z = sum_z / geometry.vertices.length;

    camera.position.x = (sum_x) * 100;
    camera.position.y = (sum_y) * 100;
    camera.position.z = (sum_z) * 100;
    console.log((sum_x) * 100)
    console.log((sum_y) * 100)
    console.log((sum_z) * 100)

    setTimeout(function(){  //hover 효과, 이벤트 감지가 어려워 다소 위험하다.
        var event = {preventDefault : function(){}, stopPropagation : function(){}};
        var addMoreX = 1;
        var addMoreY = 2;
        if(search_name == 'United States'){
            addMoreY = 22.5;
        } else if(search_name == 'United Kingdom'){
            addMoreX = -4;
            addMoreY = 15.5;
        }
        else if(search_name == 'Puerto Rico' ||search_name =='Guadeloupe'){
            addMoreX = 0.15;
            addMoreY = 0.15;
        }
        event.clientX = main_element.clientWidth/2-addMoreX;
        event.clientY = main_element.clientHeight/2+addMoreY;

        commonSearch(event, true);
    },220);
    return;
}

//클릭 이벤트 처리
function onGlobeClick(event){
    event.preventDefault();
    event.stopPropagation();
    commonSearch(event);
}

function commonSearch(event, selectNational){
    if(selectNational){
      stopAnimateAndSelectNational();
    }

    var mouseX = (event.clientX / main_element.clientWidth) * 2 - 1;
    var mouseY = -(event.clientY / main_element.clientHeight) * 2 + 1;
    var vector = new THREE.Vector3(mouseX, mouseY, -1);
    vector.unproject(camera);
    base_globe.children.map(function(element){  //초기화
        element.scale.set(1, 1, 1);
        if(element.material.color.r == 0.03529411764705882 && element.material.color.g == 0.19215686274509805 && element.material.color.b == 0.3333333333333333){

            var color = new THREE.Color(0xff0000);
            console.log("element.userData.country>"+element.userData.country)
            color.setHSL(continents.indexOf(country_data[element.userData.country].data.cont) * (1 / 7), Math.random() * 0.25 + 0.65, Math.random() / 2 + 0.25);
            element.material.color = color;
        }
        return element;
    });

    var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
    var intersects = raycaster.intersectObject(base_globe, true);

    if (intersects.length > 0) {
        if (intersects[0].point !== null) {
            if (intersects[0].object.name === "land") {
                overlay_element.innerHTML = intersects[0].object.userData.country + ', 여기에 표출 or 클릭이벤트로 그래프 보여주기';
                intersects[0].object.scale.set(hover_scale, hover_scale, hover_scale);
                intersects[0].object.material.color.set('#093155');
                isSelected = {'result':true,'name':intersects[0].object.userData.country};
            } else {
                overlay_element.innerHTML = '';
                isSelected = {result:false,name:null};
            }
        } else {
            overlay_element.innerHTML = '';
            isSelected = {result:false,name:null};
        }
    } else {
        overlay_element.innerHTML = '';
        isSelected = {result:false,name:null};
    }

    //드래그 및 클릭 색상 변경이벤트 등 애니메이트 프레임 다시 씌워주기
    if(cRAF == null || cRAF == undefined){
        clickAfterAnimate();
    }
}

function onWindowResize() {
    camera.aspect = main_element.clientWidth / main_element.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(main_element.clientWidth, main_element.clientHeight);
}

function onDocumentMouseMove(event) {

}

//default animate
function animate(time, animation){
  autoRotation();
  controls.update();
  renderer.render(scene, camera);
  rAF = requestAnimationFrame(animate);
}

//자동 회전 시키기
function autoRotation(){
  //camera를 rotation 시키면 드래그 이벤트시 camera가 돌리는 위치만 고정됨.
  //scene로 공간을 돌려서 처리
  scene.rotation.y += 0.005;
}

//메뉴 현황 클릭시
function clickAfterAnimate(time){
  controls.update();
  renderer.render(scene, camera);
  cRAF = requestAnimationFrame(clickAfterAnimate);
}

//메뉴 클릭시 회전 멈추고 애니메이션 재동작 - 재귀함수로 자신을 호출
function stopAnimateAndSelectNational(){
  if(rAF != null || rAF != undefined){
    cancelAnimationFrame(rAF);
    rAF = null;
  }
  scene.rotation.y = 0;
  controls.update();
  renderer.render(scene, camera);
}

// 애니메이션 동작(시작, 멈춤)
function animateContrller(evt, param){
  if(evt != undefined && evt != null){
      evt.preventDefault();
      evt.stopPropagation();
  }

  if(param == "move"){

    if(rAF == null || rAF == undefined){
        animate();
        cancelAnimationFrame(cRAF);
        cRAF = null;
    }
  }else if(param == "stop"){

    if(rAF != null || rAF != undefined){
        cancelAnimationFrame(rAF);
        clickAfterAnimate();
        rAF = null;
    }
  }else{ //error
    // console.log("An incorrect command");
    retrun;
  }

}

function clickZoom(evt,type){
    evt.preventDefault();
    evt.stopPropagation();
    if(type=='detail'){
        controls.mousewheelExport(getBrowserType(50));
    } else{
        controls.mousewheelExport(getBrowserType(-50));
    }
}

function getBrowserType(num){
    return {wheelDelta:num,detail:false};
}

function getRandomColor() {  //테스트용
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}

/*
* @Func > insertTextOnGlobe > 지구본 위에 글씨 집어 넣기
* @param {String} 생성하고자 하는 글자 입력 > 한국에서 입력나라로 곡선 만듬
* @param {Number} 글자 위치 x축
* @param {Number} 글자 위치 y축
* @param {Number} 글자 위치 z축
* @param {Number} 텍스트 컬러 16진수 > (사용 안함)
* @return void;
*/
function insertTextOnGlobe(inputText, ix, iy, iz, tc){
   // e:/project/three.js-dev/three.js-dev/examples/webgl_geometry_text_shapes.html 참고

   var loader = new THREE.FontLoader();
   //사용할 폰트를 json형식으로 로드한다.

   // loader.load('fonts/helvetiker_regular.typeface.json', function(font){
   loader.load('fonts/SpoqaHanSans-Regular_Regular.json', function(font){
     const TEXTSIZE = 0.1; //글씨 크기
     const TEXTCOLOR = 0xFFFFFF; //글씨 색상 default color white

     var x = 0, y = 0, z = 0; //좌표 처리
     if(ix != null && ix != undefined){
       x = ix;
     }
     if(iy != null && iy != undefined){
       y = iy;
     }
     if(iz != null && iz != undefined){
       z = iz;
     }

     var matDark = new THREE.LineBasicMaterial({
       color: TEXTCOLOR,
       side: THREE.DoubleSide
     });

     var matLite = new THREE.MeshBasicMaterial({
       color: TEXTCOLOR,
       transparent: true,
       opacity: 1,
       side: THREE.DoubleSide
     });

     var message = "메시지를 입력합니다.";
     // if(inputText != null && inputText != undefined && inputText != ""){
     //   message = inputText;
     // }
     var shapes = font.generateShapes( message, TEXTSIZE );
     var geometry = new THREE.ShapeBufferGeometry( shapes );
     geometry.computeBoundingBox();
     var xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
     geometry.translate( xMid, 0, 0 );

     var text = new THREE.Mesh( geometry, matLite );
     text.scale.x = -1; //기준이 지구본 정가운데라서 처리 안해주면 텍스트가 반전되어 나옴.
     text.position.set( x, y, z ); //글자 자리 위치시키기
     text.lookAt( new THREE.Vector3( 0, 0, 0 ) ); //lookAt 처리를 해줘야 지구본 중심(0,0,0)을 향해 글자가 정렬 됨.
     scene.add( text );
   });
 }

/*
* @Func > fligthLineTestFunc > 한국기준 곡선만들고 scene 추가 함수
* @param {String} 국가 입력 > 한국에서 입력나라로 곡선 만듬
* @return void;
*/
function fligthLineTestFunc(target_name){
  //******************************임시******************************
  //curve flight 하드코딩 테스트용

  var country_map = {
    kor: {
      x: -0.6511796956614361 * EARTH_SIZE,
      y: 0.6057371400042327 * EARTH_SIZE,
      z: 0.4979957922184134 * EARTH_SIZE
    },
    "Brazil": {
      x: 0.8579124362882554 * EARTH_SIZE,
      y: -0.18487131947124189 * EARTH_SIZE,
      z: -0.6162349686605518 * EARTH_SIZE
    },
    "China": {
      x: -0.8225818401427082 * EARTH_SIZE,
      y:  0.6353151732036072 * EARTH_SIZE,
      z: 0.22583520951312502 * EARTH_SIZE
    },
    "Germany": {
      x: -0.11128690615423284 * EARTH_SIZE,
      y:  0.7963201099104613 * EARTH_SIZE,
      z: -0.6246405794825906 * EARTH_SIZE
    },
    "Uganda": {
      x: -0.540838492388804 * EARTH_SIZE,
      y: 0.02731649615207809 * EARTH_SIZE,
      z: -0.8627698275575216 * EARTH_SIZE
    }
  };

  var targetX = country_map[target_name].x;
  var targetY = country_map[target_name].y;
  var targetZ = country_map[target_name].z;

  var startPoint = new THREE.Vector3(country_map.kor.x, country_map.kor.y, country_map.kor.z);
  var endPoint = new THREE.Vector3(targetX, targetY, targetZ);
  var spArr = vector3toLatLon(startPoint);
  var epArr = vector3toLatLon(endPoint);
  var targetArr = new Array();
  var rP = null;
  for(i=0; i<4; i++){
	   if(i>1){
        targetArr[i] = epArr[i-2];
     }else{
       targetArr[i] = spArr[i];
     }
  }

  //curve곡선 이어주기
  var curve = getSplineFromCoords(targetArr);

  var curveGeometry = new THREE.Geometry();
  // 시작~ 중간1~ 중간2~ 도착 까지 50개의 지점을 자동으로 생성하여 매끄러운 곡선을 생성한다.
  curveGeometry.vertices = curve.getPoints( 50 );
  // 생성할 곡선 속성 변경 - 색상, 두께, 형태 등
  var curveMaterial = new THREE.LineBasicMaterial({
    color : 0xFFA500, linewidth: 20, linecap: 'round', linejoin:  'round'
  });
  var curveLine = new THREE.Line( curveGeometry, curveMaterial );
  // 생성한 곡선 추가
  scene.add(curveLine);
  //******************************임시******************************
}

// function fligthLineTestFunc(target_name){
//   //******************************임시******************************
//   //curve flight 하드코딩 테스트용
//
//   var country_map = {
//     kor: {
//       x: -0.6511796956614361 * EARTH_SIZE,
//       y: 0.6057371400042327 * EARTH_SIZE,
//       z: 0.4979957922184134 * EARTH_SIZE
//     },
//     "Brazil": {
//       x: 0.8579124362882554 * EARTH_SIZE,
//       y: -0.18487131947124189 * EARTH_SIZE,
//       z: -0.6162349686605518 * EARTH_SIZE
//     },
//     "China": {
//       x: -0.8225818401427082 * EARTH_SIZE,
//       y:  0.6353151732036072 * EARTH_SIZE,
//       z: 0.22583520951312502 * EARTH_SIZE
//     },
//     "Germany": {
//       x: -0.11128690615423284 * EARTH_SIZE,
//       y:  0.7963201099104613 * EARTH_SIZE,
//       z: -0.6246405794825906 * EARTH_SIZE
//     },
//     "Uganda": {
//       x: -0.540838492388804 * EARTH_SIZE,
//       y: 0.02731649615207809 * EARTH_SIZE,
//       z: -0.8627698275575216 * EARTH_SIZE
//     }
//   };
//
//   var mid = {
//     x1: 0, y1: 0, z1: 0,
//     x2: 0, y2: 0, z2: 0
//   };
//
//   var targetX = country_map[target_name].x;
//   var targetY = country_map[target_name].y;
//   var targetZ = country_map[target_name].z;
//
//   const MIN_ALTITUE = 3;  //3 default
//   const MAX_ALTITUE = 7;  //7 default
//   var mid1_point = 0.25;
//   var mid2_point = 0.75;
//
//   //중간 mid 포인트 잡는 식을 만들어야 함... 하드코딩으로 각 국가별 테스트중
//   if(target_name == "China" || target_name == "Germany"){ //중국, 독일
//     mid.x1 = (country_map.kor.x + targetX) * mid1_point * MIN_ALTITUE;
//     mid.y1 = (country_map.kor.y + targetY) * mid1_point * MIN_ALTITUE;
//     mid.z1 = (country_map.kor.z + targetZ) * mid1_point * MIN_ALTITUE;
//     mid.x2 = (country_map.kor.x + targetX) * mid2_point;
//     mid.y2 = (country_map.kor.y + targetY) * mid2_point;
//     mid.z2 = (country_map.kor.z + targetZ) * mid2_point;
//   }else if(target_name == "Brazil"){ //브라질
//     //브라질 하드코딩... mid1 포인트를 더하는 대상을 중국으로 잡으면 잘됨...???
//     mid.x1 = (country_map.kor.x + country_map["China"].x) * mid1_point * MIN_ALTITUE;
//     mid.y1 = (country_map.kor.y + country_map["China"].y) * mid1_point * MIN_ALTITUE;
//     mid.z1 = (country_map.kor.z + country_map["China"].z) * mid1_point * MIN_ALTITUE;
//     mid.x2 = (country_map.kor.x + targetX) * mid2_point * MAX_ALTITUE;
//     mid.y2 = (country_map.kor.y + targetY) * mid2_point * MAX_ALTITUE;
//     mid.z2 = (country_map.kor.z + targetZ) * mid2_point * MAX_ALTITUE;
//   }else if(target_name == "Uganda"){ //우간다 -> 이쁘지가 않음 너무 많이 올라갓다가 떨어짐
//     mid.x1 = (country_map.kor.x + country_map["China"].x) * mid1_point * MIN_ALTITUE;
//     mid.y1 = (country_map.kor.y + country_map["China"].y) * mid1_point * MIN_ALTITUE;
//     mid.z1 = (country_map.kor.z + country_map["China"].z) * mid1_point * MIN_ALTITUE;
//     mid.x2 = (country_map.kor.x + targetX) * mid2_point * MIN_ALTITUE;
//     mid.y2 = (country_map.kor.y + targetY) * mid2_point * MIN_ALTITUE;
//     mid.z2 = (country_map.kor.z + targetZ) * mid2_point * MIN_ALTITUE;
//   }else{
//     console.log("Target Name Error!!!");
//     return;
//   }
//   //시작지점
//   console.log("South Korea x"+country_map.kor.x); console.log("South Korea y"+country_map.kor.y); console.log("South Korea z"+country_map.kor.z); console.log("")
//   //최종 mid 포인트
//   console.log("mid X1 >"+mid.x1+"   X2 >"+mid.x2); console.log("mid X1 >"+mid.y1+"   Y2 >"+mid.y2); console.log("mid X1 >"+mid.z1+"   Z2 >"+mid.z2); console.log("")
//   //도착지점
//   console.log(target_name+" x"+targetX); console.log(target_name+" y"+targetY); console.log(target_name+" z"+targetZ); console.log("")
//
//   //curve곡선 이어주기
//   //CubicBezierCurve3 > 시작지점, 중간1, 중간2, 도착지점으로 구성
//   var curve = new THREE.CubicBezierCurve3(
//     new THREE.Vector3( country_map.kor.x, country_map.kor.y, country_map.kor.z ),
//     new THREE.Vector3( mid.x1, mid.y1, mid.z1 ),
//     new THREE.Vector3( mid.x2, mid.y2, mid.z2 ),
//     new THREE.Vector3( targetX, targetY, targetZ )
//   );
//
//   var curveGeometry = new THREE.Geometry();
//   // 시작~ 중간1~ 중간2~ 도착 까지 50개의 지점을 자동으로 생성하여 매끄러운 곡선을 생성한다.
//   curveGeometry.vertices = curve.getPoints( 50 );
//   // 생성할 곡선 속성 변경 - 색상, 두께, 형태 등
//   var curveMaterial = new THREE.LineBasicMaterial({
//     color : 0xFFA500, linewidth: 20, linecap: 'round', linejoin:  'round'
//   });
//   var curveLine = new THREE.Line( curveGeometry, curveMaterial );
//   // 생성한 곡선 추가
//   scene.add(curveLine);
//   //******************************임시******************************
// }



//vector to lat, lon
function vector3toLatLon( vector3 )
{
    vector3.normalize();
    //longitude = angle of the vector around the Y axis
    //-( ) : negate to flip the longitude (3d space specific )
    //- PI / 2 to face the Z axis
    var lng = -( Math.atan2( -vector3.z, -vector3.x ) ) - Math.PI / 2;

    //to bind between -PI / PI
    if( lng < - Math.PI )lng += Math.PI * 2;

    //latitude : angle between the vector & the vector projected on the XZ plane on a unit sphere

    //project on the XZ plane
    var p = new THREE.Vector3( vector3.x, 0, vector3.z );
    //project on the unit sphere
    p.normalize();

    //commpute the angle ( both vectors are normalized, no division by the sum of lengths )
    var lat = Math.acos( p.dot( vector3 ) );

    //invert if Y is negative to ensure teh latitude is comprised between -PI/2 & PI / 2
    if( vector3.y < 0 ) lat *= -1;

    return [ lat, lng ];
}

const GLOBE_RADIUS = 20;
const CURVE_MIN_ALTITUDE = 5;
const CURVE_MAX_ALTITUDE = 20;
const DEGREE_TO_RADIAN = Math.PI / 180;

function clamp(num, min, max) {
  return num <= min ? min : (num >= max ? max : num);
}

//function to convert lat/lng to 3D point on globe
function coordinateToPosition(lat, lng, rad) {
  var radius = 1;
  var out = new THREE.Vector3();
  //flips the Y axis
  lat = Math.PI / 2 - lat;

  if(rad != null && rad != undefined && rad != 0){
    radius = rad;
  }

  var x = Math.sin( lat ) * Math.sin( lng ) * radius;
  var y = Math.cos( lat ) * radius;
  var z = Math.sin( lat ) * Math.cos( lng ) * radius;

  //distribute to sphere
  out.set( x, y, z );
  return out;
}

function getSplineFromCoords(coords) {
  const startLat = coords[0];
  const startLng = coords[1];
  const endLat = coords[2];
  const endLng = coords[3];

  // start and end points
  const start = coordinateToPosition(startLat, startLng, 20);
  const end = coordinateToPosition(endLat, endLng, 20);
  console.log(start, end);
  // altitude
  const altitude = clamp(start.distanceTo(end) * .75, CURVE_MIN_ALTITUDE, CURVE_MAX_ALTITUDE);
  console.log(start.distanceTo(end) * .75, altitude);
  // 2 control points
  const interpolate = d3.geoInterpolate([startLng, startLat], [endLng, endLat]);
  const midCoord1 = interpolate(0.25);
  const midCoord2 = interpolate(0.75);
  const mid1 = coordinateToPosition(midCoord1[1], midCoord1[0], 25+altitude);
  const mid2 = coordinateToPosition(midCoord2[1], midCoord2[0], 25+altitude);

  //CubicBezierCurve3 > 시작지점, 중간1, 중간2, 도착지점으로 구성
  return new THREE.CubicBezierCurve3(start, mid1, mid2, end);
  // return {
  //   start,
  //   end,
  //   spline: new THREE.CubicBezierCurve3(start, mid1, mid2, end)
  // };
}

/*
* @Func > createFlightLine > 기준부터 타겟까지 곡선만들고 scene 추가 처리 함수
* @param {Object} 기준이 될 국가의 Vector3 입력 시작점
* @param {Object} 타겟이 될 국가의 Vector3 입력 도착점
* @return void;
*/
function createFlightLine(sv, tv){
  //******************************임시******************************
  var startPoint = null;
  var endPoint = null;

  if(sv != null && sv != undefined &&
  tv != null && tv != undefined){

    startPoint = sv;
    endPoint = tv;
  }else{
    return;
  }

  var spArr = vector3toLatLon(startPoint);
  var epArr = vector3toLatLon(endPoint);
  var targetArr = new Array();
  if(spArr.length + epArr.length == 4){
    for(i=0; i<4; i++){

  	   if(i<2)
         targetArr[i] = spArr[i];
       else
         targetArr[i] = epArr[i-2];
    }
  }

  //curve곡선 이어주기
  var curve = getSplineFromCoords(targetArr);

  var curveGeometry = new THREE.Geometry();
  // 시작~ 중간1~ 중간2~ 도착 까지 50개의 지점을 자동으로 생성하여 매끄러운 곡선을 생성한다.
  curveGeometry.vertices = curve.getPoints( 50 );
  // 생성할 곡선 속성 변경 - 색상, 두께, 형태 등
  var curveMaterial = new THREE.LineBasicMaterial({
    color : 0xFFA500, linewidth: 20, linecap: 'round', linejoin:  'round'
  });
  var curveLine = new THREE.Line( curveGeometry, curveMaterial );
  // 생성한 곡선 추가
  scene.add(curveLine);
  //******************************임시******************************
}
